#!/bin/bash
# VERSION: 1.4.1 Linux
VERSION=1.4.2b
#
# CREDITS
# Original from: http://www.mikerubel.org/computers/rsync_snapshots/
# Customized by Jesus Cuenca
# DESCRIPTION
# Backup a directory using rsync (Cygwin version)
#
# CHANGES
#    Release 1.4.2b
# - added OS X support
# - replacing the restricted program mechanism ($CP and the like) with a
#   restricted path (should be OS dependent)
# - autodetection of working dir, based on $0
#
#    Release 1.4
# - autoupdate from update server, both the program code and the backup configuration. Updates must be downloaded
#   without ssh, to be able to download updates even if there are key problems
# - new configuration scheme (3 files)
# - use server side excludes
# - don't write to stdout since it confuses cron
#
# TODO
# - autoupdate of schedule and backup config
# - both local and remote logging of the same messages
# - mechanism to preserve autoupdates in case of script corruption
# - add network connection event as a trigger to start the script (for road warriors)
# - learn mode: measure computer's power on times and then estimate the best moment to perform the backup
# - unify linux / windows / mac versions
# - improve code style & legibility
#
# CONFIG FILES
#   backup -- module + sources
#   server_key -- backup server ssh host key
#   schedule -- when to do backups (cron format)

unset PATH
PATH=/usr/bin:/bin

# Global variables

# If SKIP_BACKUP equals 1, the backup of the data is not performed
SKIP_BACKUP=0

# Location of system programs (like cp, mktemp...)
BIN_DIR=/usr/bin
WORKING_DIR=/etc/cron_scripts

# For what OS this version of the script is intended. Supported platforms: linux,osx,win
TARGET_OS=linux

if [ $TARGET_OS == "linux" ]
then
	BIN_DIR=/bin
fi

OS=`uname`
INSTALL_DIR=`dirname $0`

cd $INSTALL_DIR

# This script needs the following programs
RSYNC=/usr/bin/rsync
SU=$BIN_DIR/su
CDS=/usr/local/bin/check_dangling_symlink
DATE=/bin/date
SSH=/usr/bin/ssh
CAT=$BIN_DIR/cat
RM=$BIN_DIR/rm
SLEEP=$BIN_DIR/sleep
CP=$BIN_DIR/cp
MV=$BIN_DIR/mv
DIRNAME=/usr/bin/dirname
SED=$BIN_DIR/sed
MKDIR=$BIN_DIR/mkdir
MKTEMP=$BIN_DIR/mktemp
AWK=/usr/bin/awk

# The name of the file that will be downloaded from the server to update the current version of the program
UPDATE_NAME=rsync_backup_$TARGET_OS

# The name of the file with the backup server public key
SERVER_KEY=server_key

KNOWN_HOSTS=$HOME/.ssh/known_hosts

LOG_NAME=rsync_backup.log
LOG_FILE=/var/log/$LOG_NAME

if [ $OS == "Darwin" ]
then
	LOG_FILE=$INSTALL_DIR/$LOG_NAME
fi

# This file contains the date and time of last check for updates, in seconds since 1970
LAST_UPDATE_CHECK_FILE=.last_update_check

# How frequently to check for updates, in seconds. 86400 seconds == 1 day
UPDATE_CHECK_PERIOD=86400

# This file stores what it is copied and where.
BACKUP_CONFIG=backup

# EXCLUDES=rsync_excludes

# Pre 1.4 config variables
WHAT_CFG=$HOME/.rsync_what.cfg
RM_CFG=$HOME/.rsync_remote_module.cfg
SOURCE_DIR=/cygdrive/

# Server name, long and short
SERVER=disco.cnb.csic.es
SERVER_SHORT=disco

REMOTE_USER=root

# The name of the rsync module in the server that collects the updates
UPDATE_MODULE=updates

update(){
	# perform all the self-update functions
	# 1) download latest server public key if newer
	# 2) download latest version of the script if newer
	
	UPDATED=0
	ERROR=0
	
	# check updates once in a UPDATE_CHECK_PERIOD 
	CURRENT_DATE=`$DATE +%s`
	
	if [ -f $LAST_UPDATE_CHECK_FILE ]
	then
		LAST_UPDATE_CHECK=`$CAT $LAST_UPDATE_CHECK_FILE`
	else
		# If there were not any check, force an update check
		LAST_UPDATE_CHECK=`expr $CURRENT_DATE - $UPDATE_CHECK_PERIOD`
	fi
	
	TIME_SINCE_LAST_UPDATE_CHECK=`expr $CURRENT_DATE - $LAST_UPDATE_CHECK`

	if [ $TIME_SINCE_LAST_UPDATE_CHECK -ge $UPDATE_CHECK_PERIOD ]
	then
		echo Checking for updates...
		update_server_key
		ERROR=`expr $ERROR + $?`
		
		# rsync compares current version and remote version by CRC ( -c option)
		 $RSYNC -avnc $REMOTE_USER@$SERVER::$UPDATE_MODULE/$UPDATE_NAME . | grep $UPDATE_NAME
		 if [ $? -eq 0 ]
		 then
		 		# there's a new version
		 		echo Downloading updates...
		 		$RSYNC -a $REMOTE_USER@$SERVER::$UPDATE_MODULE/$UPDATE_NAME $UPDATE_NAME.new
		 		ERROR=`expr $ERROR + $?`
		 		echo Updating...
		 		./$UPDATE_NAME.new replace_old &
		 		UPDATED=1
		 fi
		 
		 if [ $ERROR -eq 0 ]
		 then 
		 		# If there were no problems, register this update's date
		 	 	echo $CURRENT_DATE > $LAST_UPDATE_CHECK_FILE
		 fi
		 echo Done.
	fi
	
	return $UPDATED
}


# Be careful with this function, since it's called from old version to new version, and it may break
# the update process
# Keep a copy of the previous script
replace_old(){
	# Give time to the old program to exit before we replace it
	$SLEEP 2
	$CP $UPDATE_NAME $UPDATE_NAME.old
	$MV $UPDATE_NAME.new $UPDATE_NAME
	echo Updated.
}


update_server_key(){
	# The SSH host key of the server may change with time. When the key changes, all the clients refuse to connect
	# to prevent a 'man in the middle' attack. So, it's neccesary to replace the old keys in this cases.
		# perform all the self-update functions
	# 1) download latest version if newer
	
	KNOWN_HOSTS_DIR=`$DIRNAME $KNOWN_HOSTS`
	if [ ! -d $KNOWN_HOSTS_DIR ]
	then
		$MKDIR -p $KNOWN_HOSTS_DIR
	fi
	
	# rsync compares current version and remote version by CRC ( -c option)
	 $RSYNC -avnc $REMOTE_USER@$SERVER::$UPDATE_MODULE/$SERVER_KEY . | grep $SERVER_KEY
	 if [ $? -eq 0 ]
	 then
	 		# there's a new version
	 		echo Updating server key...
	 		$RSYNC -a $REMOTE_USER@$SERVER::$UPDATE_MODULE/$SERVER_KEY .
	 		
	 		TMP_FILE=`$MKTEMP`
	 		# Erase old key from known_hosts, then append the new
	 		if [ -f $KNOWN_HOSTS ]
	 		then
	 		 		$SED -e "/$SERVER_SHORT/,/==/ d" < $KNOWN_HOSTS > $TMP_FILE
	 		fi
	 		$CAT $SERVER_KEY >> $TMP_FILE
	 		$MV $TMP_FILE $KNOWN_HOSTS
	 fi
	 
}

check_configuration_files(){
	# Check that configuration files exist
	if [ ! -f $BACKUP_CONFIG ]
	then
		if [ -f $WHAT_CFG ]
		then
			# Migrate from old config format
			# If it's missing the /cygdrive in path, add it
			grep cygdrive $WHAT_CFG
			if [ $? -ne 0 ]
			then
				WHAT=`$SED -e s_^_/cygdrive/_g < $WHAT_CFG | $SED -e s_\ _\ /cygdrive/_g`
			else
				WHAT=`$CAT $WHAT_CFG`
			fi
			REMOTE_MODULE=`$CAT $RM_CFG`
			echo $REMOTE_MODULE $WHAT > $BACKUP_CONFIG
			$MV $WHAT_CFG $WHAT_CFG.kk
			$MV $RM_CFG $RM_CFG.kk
		else
			echo $BACKUP_CONFIG is missing
			exit 1
		fi
	else
		# Check if it's old format
		grep RSYNC $BACKUP_CONFIG > /dev/null
		if [ $? -eq 0 ]
		then
			# Convert to new format, making a backup
			$CP $BACKUP_CONFIG $BACKUP_CONFIG.old
			grep -v "#" $BACKUP_CONFIG.old | $AWK '! /^$/{print $3 " " $2}' > $BACKUP_CONFIG
			echo Please verify the new $BACKUP_CONFIG \(remove blank lines, replace SYSTEM with system dirs\)
		fi
	fi

#	if [ ! -f $EXCLUDES ]
#	then
#		echo $EXCLUDES is missing
#		exit 1
#	fi
	
}

backup(){
	
	check_configuration_files
	
#  REMOTE_MODULE=`$CAT $RM_CFG`
#	WHAT=`$CAT $WHAT_CFG`

	# Get what to backup from config file. This old file structure is
	# Headers
	# $RSYNC_BACKUP SOURCE MODULE
	# Read old file with
	# $GREP \\\$RSYNC $BACKUP_CONFIG | $GREP -v \\\# | while read PROGRAM WHAT REMOTE_MODULE
	
	# New file structure allows multiple sources for one module:
	# MODULE SOURCE1 SOURCE2...
	# Source's paths should be absolute

	
	$CAT $BACKUP_CONFIG | while read REMOTE_MODULE WHAT
	do
		echo Backing up $WHAT to $REMOTE_MODULE... >> $LOG_FILE
		# cygwin cron is affected by the output of the job, so the command must be completely quiet
		# use -L to follow symlinks
		# server:module -> ssh ; server::module -> rsync . So, with :: the -e option is needed
		
		if [ $SKIP_BACKUP -eq 0 ]
		then
			$RSYNC -rt -e $SSH --delete --delete-excluded $WHAT $REMOTE_USER@$SERVER::$REMOTE_MODULE &> /tmp/rsync_backup.log.tmp
			$CAT /tmp/rsync_backup.log.tmp >> $LOG_FILE
		fi

	done

	$RM /tmp/rsync_backup.log.tmp
	
	echo Finished `$DATE` >> $LOG_FILE
	echo >> $LOG_FILE
	
}

# Copy the local rsync log file to the server in the first module that appears
# in the backup config file
sync_log(){
	read REMOTE_MODULE WHAT < $BACKUP_CONFIG
	$RSYNC -a -e $SSH $LOG_FILE $REMOTE_USER@$SERVER::$REMOTE_MODULE
}

echo_log(){
	echo $1 >> $LOG_FILE
}
syntax(){
	echo Syntax: $0 [COMMAND]
	echo COMMAND can be: replace_old
	echo If no command is specified, it does normal operations \(self-update / backup\)

}

############## Main


echo $0 version $VERSION started. `$DATE`. >> $LOG_FILE

# Process parameters - see syntax
if [ $# -eq 1 ]
then
	# Be careful with this parameter, renaming or modifying it may break the update process
	if [ $1 == replace_old ]
	then
		echo Replacing old version...
		replace_old
		exit 0
	fi
fi

if [ $# -gt 1 ]
then
	echo Wrong number of parameters
	syntax
	exit 1
fi

update
if [ $? -eq 0 ]
then
	# The script was not updated
	backup
	sync_log
fi
# echo Exit $$
